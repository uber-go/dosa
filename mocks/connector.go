// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/uber-go/dosa (interfaces: Connector)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	dosa "github.com/uber-go/dosa"
	reflect "reflect"
)

// MockConnector is a mock of Connector interface
type MockConnector struct {
	ctrl     *gomock.Controller
	recorder *MockConnectorMockRecorder
}

// MockConnectorMockRecorder is the mock recorder for MockConnector
type MockConnectorMockRecorder struct {
	mock *MockConnector
}

// NewMockConnector creates a new mock instance
func NewMockConnector(ctrl *gomock.Controller) *MockConnector {
	mock := &MockConnector{ctrl: ctrl}
	mock.recorder = &MockConnectorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockConnector) EXPECT() *MockConnectorMockRecorder {
	return m.recorder
}

// CanUpsertSchema mocks base method
func (m *MockConnector) CanUpsertSchema(arg0 context.Context, arg1, arg2 string, arg3 []*dosa.EntityDefinition) (int32, error) {
	ret := m.ctrl.Call(m, "CanUpsertSchema", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(int32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CanUpsertSchema indicates an expected call of CanUpsertSchema
func (mr *MockConnectorMockRecorder) CanUpsertSchema(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanUpsertSchema", reflect.TypeOf((*MockConnector)(nil).CanUpsertSchema), arg0, arg1, arg2, arg3)
}

// CheckSchema mocks base method
func (m *MockConnector) CheckSchema(arg0 context.Context, arg1, arg2 string, arg3 []*dosa.EntityDefinition) (int32, error) {
	ret := m.ctrl.Call(m, "CheckSchema", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(int32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckSchema indicates an expected call of CheckSchema
func (mr *MockConnectorMockRecorder) CheckSchema(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckSchema", reflect.TypeOf((*MockConnector)(nil).CheckSchema), arg0, arg1, arg2, arg3)
}

// CheckSchemaStatus mocks base method
func (m *MockConnector) CheckSchemaStatus(arg0 context.Context, arg1, arg2 string, arg3 int32) (*dosa.SchemaStatus, error) {
	ret := m.ctrl.Call(m, "CheckSchemaStatus", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(*dosa.SchemaStatus)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckSchemaStatus indicates an expected call of CheckSchemaStatus
func (mr *MockConnectorMockRecorder) CheckSchemaStatus(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckSchemaStatus", reflect.TypeOf((*MockConnector)(nil).CheckSchemaStatus), arg0, arg1, arg2, arg3)
}

// CreateIfNotExists mocks base method
func (m *MockConnector) CreateIfNotExists(arg0 context.Context, arg1 *dosa.EntityInfo, arg2 map[string]dosa.FieldValue) error {
	ret := m.ctrl.Call(m, "CreateIfNotExists", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateIfNotExists indicates an expected call of CreateIfNotExists
func (mr *MockConnectorMockRecorder) CreateIfNotExists(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateIfNotExists", reflect.TypeOf((*MockConnector)(nil).CreateIfNotExists), arg0, arg1, arg2)
}

// CreateScope mocks base method
func (m *MockConnector) CreateScope(arg0 context.Context, arg1 *dosa.ScopeMetadata) error {
	ret := m.ctrl.Call(m, "CreateScope", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateScope indicates an expected call of CreateScope
func (mr *MockConnectorMockRecorder) CreateScope(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateScope", reflect.TypeOf((*MockConnector)(nil).CreateScope), arg0, arg1)
}

// DropScope mocks base method
func (m *MockConnector) DropScope(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, "DropScope", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DropScope indicates an expected call of DropScope
func (mr *MockConnectorMockRecorder) DropScope(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DropScope", reflect.TypeOf((*MockConnector)(nil).DropScope), arg0, arg1)
}

// MultiRead mocks base method
func (m *MockConnector) MultiRead(arg0 context.Context, arg1 *dosa.EntityInfo, arg2 []map[string]dosa.FieldValue, arg3 []string) ([]*dosa.FieldValuesOrError, error) {
	ret := m.ctrl.Call(m, "MultiRead", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].([]*dosa.FieldValuesOrError)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MultiRead indicates an expected call of MultiRead
func (mr *MockConnectorMockRecorder) MultiRead(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MultiRead", reflect.TypeOf((*MockConnector)(nil).MultiRead), arg0, arg1, arg2, arg3)
}

// MultiRemove mocks base method
func (m *MockConnector) MultiRemove(arg0 context.Context, arg1 *dosa.EntityInfo, arg2 []map[string]dosa.FieldValue) ([]error, error) {
	ret := m.ctrl.Call(m, "MultiRemove", arg0, arg1, arg2)
	ret0, _ := ret[0].([]error)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MultiRemove indicates an expected call of MultiRemove
func (mr *MockConnectorMockRecorder) MultiRemove(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MultiRemove", reflect.TypeOf((*MockConnector)(nil).MultiRemove), arg0, arg1, arg2)
}

// MultiUpsert mocks base method
func (m *MockConnector) MultiUpsert(arg0 context.Context, arg1 *dosa.EntityInfo, arg2 []map[string]dosa.FieldValue) ([]error, error) {
	ret := m.ctrl.Call(m, "MultiUpsert", arg0, arg1, arg2)
	ret0, _ := ret[0].([]error)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MultiUpsert indicates an expected call of MultiUpsert
func (mr *MockConnectorMockRecorder) MultiUpsert(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MultiUpsert", reflect.TypeOf((*MockConnector)(nil).MultiUpsert), arg0, arg1, arg2)
}

// Range mocks base method
func (m *MockConnector) Range(arg0 context.Context, arg1 *dosa.EntityInfo, arg2 map[string][]*dosa.Condition, arg3 []string, arg4 string, arg5 int) ([]map[string]dosa.FieldValue, string, error) {
	ret := m.ctrl.Call(m, "Range", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].([]map[string]dosa.FieldValue)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Range indicates an expected call of Range
func (mr *MockConnectorMockRecorder) Range(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Range", reflect.TypeOf((*MockConnector)(nil).Range), arg0, arg1, arg2, arg3, arg4, arg5)
}

// Read mocks base method
func (m *MockConnector) Read(arg0 context.Context, arg1 *dosa.EntityInfo, arg2 map[string]dosa.FieldValue, arg3 []string) (map[string]dosa.FieldValue, error) {
	ret := m.ctrl.Call(m, "Read", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(map[string]dosa.FieldValue)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read
func (mr *MockConnectorMockRecorder) Read(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockConnector)(nil).Read), arg0, arg1, arg2, arg3)
}

// Remove mocks base method
func (m *MockConnector) Remove(arg0 context.Context, arg1 *dosa.EntityInfo, arg2 map[string]dosa.FieldValue) error {
	ret := m.ctrl.Call(m, "Remove", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Remove indicates an expected call of Remove
func (mr *MockConnectorMockRecorder) Remove(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockConnector)(nil).Remove), arg0, arg1, arg2)
}

// RemoveRange mocks base method
func (m *MockConnector) RemoveRange(arg0 context.Context, arg1 *dosa.EntityInfo, arg2 map[string][]*dosa.Condition) error {
	ret := m.ctrl.Call(m, "RemoveRange", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveRange indicates an expected call of RemoveRange
func (mr *MockConnectorMockRecorder) RemoveRange(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveRange", reflect.TypeOf((*MockConnector)(nil).RemoveRange), arg0, arg1, arg2)
}

// Scan mocks base method
func (m *MockConnector) Scan(arg0 context.Context, arg1 *dosa.EntityInfo, arg2 []string, arg3 string, arg4 int) ([]map[string]dosa.FieldValue, string, error) {
	ret := m.ctrl.Call(m, "Scan", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].([]map[string]dosa.FieldValue)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Scan indicates an expected call of Scan
func (mr *MockConnectorMockRecorder) Scan(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockConnector)(nil).Scan), arg0, arg1, arg2, arg3, arg4)
}

// ScopeExists mocks base method
func (m *MockConnector) ScopeExists(arg0 context.Context, arg1 string) (bool, error) {
	ret := m.ctrl.Call(m, "ScopeExists", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ScopeExists indicates an expected call of ScopeExists
func (mr *MockConnectorMockRecorder) ScopeExists(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScopeExists", reflect.TypeOf((*MockConnector)(nil).ScopeExists), arg0, arg1)
}

// Shutdown mocks base method
func (m *MockConnector) Shutdown() error {
	ret := m.ctrl.Call(m, "Shutdown")
	ret0, _ := ret[0].(error)
	return ret0
}

// Shutdown indicates an expected call of Shutdown
func (mr *MockConnectorMockRecorder) Shutdown() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockConnector)(nil).Shutdown))
}

// TruncateScope mocks base method
func (m *MockConnector) TruncateScope(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, "TruncateScope", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// TruncateScope indicates an expected call of TruncateScope
func (mr *MockConnectorMockRecorder) TruncateScope(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TruncateScope", reflect.TypeOf((*MockConnector)(nil).TruncateScope), arg0, arg1)
}

// Upsert mocks base method
func (m *MockConnector) Upsert(arg0 context.Context, arg1 *dosa.EntityInfo, arg2 map[string]dosa.FieldValue) error {
	ret := m.ctrl.Call(m, "Upsert", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert
func (mr *MockConnectorMockRecorder) Upsert(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockConnector)(nil).Upsert), arg0, arg1, arg2)
}

// UpsertSchema mocks base method
func (m *MockConnector) UpsertSchema(arg0 context.Context, arg1, arg2 string, arg3 []*dosa.EntityDefinition) (*dosa.SchemaStatus, error) {
	ret := m.ctrl.Call(m, "UpsertSchema", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(*dosa.SchemaStatus)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertSchema indicates an expected call of UpsertSchema
func (mr *MockConnectorMockRecorder) UpsertSchema(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertSchema", reflect.TypeOf((*MockConnector)(nil).UpsertSchema), arg0, arg1, arg2, arg3)
}
